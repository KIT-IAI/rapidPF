{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"RapidPF Rapid prototyping for distributed power flow problems The power flow problem is the cornerstone problem in power systems analysis: find all (complex) quantities in an AC electrical network in steady state. Mathematically, the power flow problem is a system of nonlinear equations g(x) = 0 g(x) = 0 that can be solved by the Newton method, for instance. However, the power flow problem can also be solved in a distributed fashion, $$ \\begin{align} g_{i}(x_i) &= 0, \\\\ \\sum_{i = 1}^{n} A_i x_i &= 0, \\end{align} $$ where i \\in \\{ 1, \\dots, n\\} i \\in \\{ 1, \\dots, n\\} corresponds to the i i -th subproblem. In plain words, the distributed power flow problem means to solve a power flow problem within each region i i whilst ensuring that the neighboring power flows satisfy the overall power flow equations. There are several advantages of distributed approaches: distribute computational effort, preserves privacy, increases reliability, and adds flexibility. What to expect The code allows to formulate distributed power flow problems easily. Specifically, the features of the code include: Starting from several individual case files, generate a merged case file for given connections. Formulate distributed power flow problems in terms of function handles. Solve distributed power flow problems using the Aladin toolbox. Fully compliant with matpower case files, hence allowing to use all of the built-in matpower functions. Insightful post-processing features. What not to expect An introduction to the power flow problem as such. There are excellent references for this, for example this one Optimal power flow problems. A collection of numerical routines to solve distributed power flow problems. A visualizer of matpower case files; use STAC for this. Installation See here. Use of matpower The code relies heavily on Matpower , especially on the idea of a matpower case file (or mpc ). This bulky name is nothing but a standardized Matlab struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, mpc can be converted within matpower to/from IEEE CDF or PSS/E RAW, see the Matpower docs for details.","title":"RapidPF"},{"location":"#rapidpf","text":"","title":"RapidPF"},{"location":"#rapid-prototyping-for-distributed-power-flow-problems","text":"The power flow problem is the cornerstone problem in power systems analysis: find all (complex) quantities in an AC electrical network in steady state. Mathematically, the power flow problem is a system of nonlinear equations g(x) = 0 g(x) = 0 that can be solved by the Newton method, for instance. However, the power flow problem can also be solved in a distributed fashion, $$ \\begin{align} g_{i}(x_i) &= 0, \\\\ \\sum_{i = 1}^{n} A_i x_i &= 0, \\end{align} $$ where i \\in \\{ 1, \\dots, n\\} i \\in \\{ 1, \\dots, n\\} corresponds to the i i -th subproblem. In plain words, the distributed power flow problem means to solve a power flow problem within each region i i whilst ensuring that the neighboring power flows satisfy the overall power flow equations. There are several advantages of distributed approaches: distribute computational effort, preserves privacy, increases reliability, and adds flexibility.","title":"Rapid prototyping for distributed power flow problems"},{"location":"#what-to-expect","text":"The code allows to formulate distributed power flow problems easily. Specifically, the features of the code include: Starting from several individual case files, generate a merged case file for given connections. Formulate distributed power flow problems in terms of function handles. Solve distributed power flow problems using the Aladin toolbox. Fully compliant with matpower case files, hence allowing to use all of the built-in matpower functions. Insightful post-processing features.","title":"What to expect"},{"location":"#what-not-to-expect","text":"An introduction to the power flow problem as such. There are excellent references for this, for example this one Optimal power flow problems. A collection of numerical routines to solve distributed power flow problems. A visualizer of matpower case files; use STAC for this.","title":"What not to expect"},{"location":"#installation","text":"See here. Use of matpower The code relies heavily on Matpower , especially on the idea of a matpower case file (or mpc ). This bulky name is nothing but a standardized Matlab struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, mpc can be converted within matpower to/from IEEE CDF or PSS/E RAW, see the Matpower docs for details.","title":"Installation"},{"location":"assumptions/","text":"Assumptions Naming convention We distinguish between a master system and several worker systems . The sole difference is that the master system contains the reference bus. Case file generator The slack bus of the master system is the slack bus of the overall system. Systems can be connected in arbitrary ways at generation buses (i.e. slack buses and/or PV buses), for instance: There may be several connections between two systems too. Warning It is currently not supported to connect several lines between the same buses. In the to -system we replace the generation bus by a PQ bus with zero generation and original demand. If the connecting generation bus in the to -worker-system is the slack bus, then this slack in the worker system is replaced by a PQ bus with zero generation/demand. On the other hand, if the connecting generation bus in the to -system is a PV bus, then this PV bus is replaced by a PQ bus If no connecting bus in the to -worker-system is the slack bus, then the worker system\u2019s slack bus is replaced by a PV bus; the respective set points for the active power and the voltage magnitude are taken from the Matpower case file entries in mpc.gen . If the master system has N_{m} N_{m} nodes, and if each worker system i i has N_{s, i} N_{s, i} nodes for i \\in \\{ 1, \\dots, d \\} i \\in \\{ 1, \\dots, d \\} , then the overall system is going to have N = N_{m} + N_{s_1} + \\dots + N_{s, d} N = N_{m} + N_{s_1} + \\dots + N_{s, d} nodes. The entries for the generated active/reactive power from the fields mpc.gen() are ignored. The numbering of the overall system (= master + workers) goes from 1 1 to N N , where N N is the number of buses in the overall system, see above. The master system contains bus numbers 1 1 to N_m N_m . The numbering of the buses in the remaining systems is done according to order of appearance. All case files have the same baseMVA . The voltage magnitude settings in mpc.gen must be equivalent. If there are several generators at a single bus, then their voltage magnitude must be the same. Case file splitter The copy buses of each region i i are added at the end of the list of core buses of region i i . Both the list of copy buses and the list of core buses are sorted in ascending order. The bus admittance matrix of region i i is created by first splitting the case for region i i including the copy buses, and then calling makeYbus (built-in matpower function). Case file parser The distributed problem is obtained by copying buses at the connecting lines, and then enforcing consensus at the original buses and their respective copies. The state x_i x_i in every region i i is composed of n_{i}^{\\text{core}} n_{i}^{\\text{core}} core entries and n_{i}^{\\text{copy}} n_{i}^{\\text{copy}} copy entries , where x_{i}^{\\text{core}} = ( \\theta_i^{\\text{core}}, v_i^{\\text{core}}, p_i^{\\text{core}}, q_i^{\\text{core}} ) \\in \\mathbb{R}^{4 n_{i}^{\\text{core}}}, x_{i}^{\\text{core}} = ( \\theta_i^{\\text{core}}, v_i^{\\text{core}}, p_i^{\\text{core}}, q_i^{\\text{core}} ) \\in \\mathbb{R}^{4 n_{i}^{\\text{core}}}, and x_{i}^{\\text{copy}} = ( \\theta_i^{\\text{copy}}, v_i^{\\text{copy}}) \\in \\mathbb{R}^{2 n_{i}^{\\text{copy}}}. x_{i}^{\\text{copy}} = ( \\theta_i^{\\text{copy}}, v_i^{\\text{copy}}) \\in \\mathbb{R}^{2 n_{i}^{\\text{copy}}}. The full state of region i i is x_i = (\\theta_i^{\\text{core}}, \\theta_i^{\\text{copy}}, v_i^{\\text{core}}, v_i^{\\text{copy}}, p_i^{\\text{core}}, q_i^{\\text{core}}) \\in \\mathbb{R}^{4 n_i^{\\text{core}} + 2 n_i^{\\text{copy}}} x_i = (\\theta_i^{\\text{core}}, \\theta_i^{\\text{copy}}, v_i^{\\text{core}}, v_i^{\\text{copy}}, p_i^{\\text{core}}, q_i^{\\text{core}}) \\in \\mathbb{R}^{4 n_i^{\\text{core}} + 2 n_i^{\\text{copy}}} .","title":"Assumptions"},{"location":"assumptions/#assumptions","text":"Naming convention We distinguish between a master system and several worker systems . The sole difference is that the master system contains the reference bus.","title":"Assumptions"},{"location":"assumptions/#case-file-generator","text":"The slack bus of the master system is the slack bus of the overall system. Systems can be connected in arbitrary ways at generation buses (i.e. slack buses and/or PV buses), for instance: There may be several connections between two systems too. Warning It is currently not supported to connect several lines between the same buses. In the to -system we replace the generation bus by a PQ bus with zero generation and original demand. If the connecting generation bus in the to -worker-system is the slack bus, then this slack in the worker system is replaced by a PQ bus with zero generation/demand. On the other hand, if the connecting generation bus in the to -system is a PV bus, then this PV bus is replaced by a PQ bus If no connecting bus in the to -worker-system is the slack bus, then the worker system\u2019s slack bus is replaced by a PV bus; the respective set points for the active power and the voltage magnitude are taken from the Matpower case file entries in mpc.gen . If the master system has N_{m} N_{m} nodes, and if each worker system i i has N_{s, i} N_{s, i} nodes for i \\in \\{ 1, \\dots, d \\} i \\in \\{ 1, \\dots, d \\} , then the overall system is going to have N = N_{m} + N_{s_1} + \\dots + N_{s, d} N = N_{m} + N_{s_1} + \\dots + N_{s, d} nodes. The entries for the generated active/reactive power from the fields mpc.gen() are ignored. The numbering of the overall system (= master + workers) goes from 1 1 to N N , where N N is the number of buses in the overall system, see above. The master system contains bus numbers 1 1 to N_m N_m . The numbering of the buses in the remaining systems is done according to order of appearance. All case files have the same baseMVA . The voltage magnitude settings in mpc.gen must be equivalent. If there are several generators at a single bus, then their voltage magnitude must be the same.","title":"Case file generator"},{"location":"assumptions/#case-file-splitter","text":"The copy buses of each region i i are added at the end of the list of core buses of region i i . Both the list of copy buses and the list of core buses are sorted in ascending order. The bus admittance matrix of region i i is created by first splitting the case for region i i including the copy buses, and then calling makeYbus (built-in matpower function).","title":"Case file splitter"},{"location":"assumptions/#case-file-parser","text":"The distributed problem is obtained by copying buses at the connecting lines, and then enforcing consensus at the original buses and their respective copies. The state x_i x_i in every region i i is composed of n_{i}^{\\text{core}} n_{i}^{\\text{core}} core entries and n_{i}^{\\text{copy}} n_{i}^{\\text{copy}} copy entries , where x_{i}^{\\text{core}} = ( \\theta_i^{\\text{core}}, v_i^{\\text{core}}, p_i^{\\text{core}}, q_i^{\\text{core}} ) \\in \\mathbb{R}^{4 n_{i}^{\\text{core}}}, x_{i}^{\\text{core}} = ( \\theta_i^{\\text{core}}, v_i^{\\text{core}}, p_i^{\\text{core}}, q_i^{\\text{core}} ) \\in \\mathbb{R}^{4 n_{i}^{\\text{core}}}, and x_{i}^{\\text{copy}} = ( \\theta_i^{\\text{copy}}, v_i^{\\text{copy}}) \\in \\mathbb{R}^{2 n_{i}^{\\text{copy}}}. x_{i}^{\\text{copy}} = ( \\theta_i^{\\text{copy}}, v_i^{\\text{copy}}) \\in \\mathbb{R}^{2 n_{i}^{\\text{copy}}}. The full state of region i i is x_i = (\\theta_i^{\\text{core}}, \\theta_i^{\\text{copy}}, v_i^{\\text{core}}, v_i^{\\text{copy}}, p_i^{\\text{core}}, q_i^{\\text{core}}) \\in \\mathbb{R}^{4 n_i^{\\text{core}} + 2 n_i^{\\text{copy}}} x_i = (\\theta_i^{\\text{core}}, \\theta_i^{\\text{copy}}, v_i^{\\text{core}}, v_i^{\\text{copy}}, p_i^{\\text{core}}, q_i^{\\text{core}}) \\in \\mathbb{R}^{4 n_i^{\\text{core}} + 2 n_i^{\\text{copy}}} .","title":"Case file parser"},{"location":"example/","text":"Example This is a beginning-to-end-example about how to solve distributed power flow with the Aladin toolbox . Click here to see the plain code. Setup Starting from the home directory of the package, let\u2019s make a tabula rasa and switch to the use case folder 1 2 clear all ; close all ; clc ; cd ( '00_use-case' ) If not done already, add the source files to the path 1 2 3 addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); We would like the following fields to be merged from the case files 1 fields_to_merge = { 'bus' , 'gen' , 'branch' }; Specify inputs We first generate a name struct that acts as a de-facto global variable for naming structs. 1 names = generate_name_struct (); Next, we specify the master and worker systems by loading their case files. 1 2 mpc_master = loadcase ( 'case14' ); mpc_workers = { loadcase ( 'case30' ); loadcase ( 'case9' ) }; Additionally, we need to specify who is connected to whom . These connections are specified in a connection array: 1 2 3 connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; The first row reads: system 2 is connected to system 1, specifically the first bus of system 2 is connected to the second bus of system 1. Likewise, the second row reads: system 2 is connected to system 3, specifically the second bus of system 2 is connected to the third bus of system 3. However, we need not just to specify who is connected to whom , but also how . Hence, we model a connecting transformer. 1 2 3 4 5 trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; Finally, we can call build_connection_table . 1 conn = build_connection_table ( connection_array , trafo_params ); Problem formulation Having done the setup, we are now ready to use the three main blocks: the case file generator, the case file splitter, and the case file parser: Case file generator Calling the case file generator means to specify the master and the workers together with the connection table, and what fields shall be merged. The most convenient way is to call run_case_file_generator 1 mpc_merge = run_case_file_generator ( mpc_master , mpc_workers , conn , fields_to_merge , names ); The output is a case file that has a lot of extra information. Case file splitter The output of the case file generator is the input to the case file splitter, together with connection information. We call run_case_file_splitter 1 mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); The output is, again, a case file that has a lot of extra information. Case file parser Finally, the case file parser takes the output from the splitter, and generates a problem formulation, using generate_distributed_problem_for_aladin . Note that we can need to specify whether we create a feasibility or a least-squares problem formulation. 1 problem = generate_distributed_problem_for_aladin ( mpc_split , names , 'least-squares' ); The problem formulation is a struct that contains all relevant equations. Finally, we need to add a numerical solver ( fmincon , fminunc , worhp , Casadi+Ipopt ) 1 2 % add a solver problem . solver = 'fmincon' ; Problem solution Having created a valid problem formulation, we rely on the Aladin toolbox to solve the problem. Aladin requires a set of parameters (using the default values is also possible, and usually a good idea). We use the function solve_distributed_problem_with_aladin 1 2 3 4 5 opts = struct ( 'maxiter' , 50 , 'solveQP' , 'MA57' ); opts . reg = 'false' ; opts . rho0 = 1e2 ; [ xsol_aladin , xsol_stack_aladin , mpc_sol_aladin , logg ] = solve_distributed_problem_with_aladin ( mpc_split , problem , names , opts ); The function returns four outputs: xsol_aladin and xsol_stack_aladin are both cells with as many entries as there are regions. In each entry, the state of region i i is stored: in xsol_aladin it is a matrix form with as many rows as there are buses in the region, and the four columns being the voltage angle, the voltage magnitude, the net active power, and the net reactive power; in xsol_stack_aladin , each entry is the vertically stacked equivalent of xsol_aladin . The third output, mpc_sol_aladin , is a valid case file that can be used for further inspection. The fourth output contains logging information from the Aladin toolbox. Comparison How do we know that the solution we computed is actually correct? For that purpose, there is a validation function such as validate_distributed_problem_formulation . Simply put, the function uses matpower to validate that the generated problem formulation stored in problem is correct. 1 [ xval , xval_stacked ] = validate_distributed_problem_formulation ( problem , mpc_split , names ); The outputs have the same format as the first two outputs ( xsol_aladin & xsol_stack_aladin ) from the problem solution . To compare the results we call compare_results , which generates a humand-readable table output. 1 comparison_aladin = compare_results ( xval , xsol_aladin ) Post-processing There is a handy function for post-processing, This function provides a graphical impression of the overall constraint violations for both the power flow equations and the consensus violations. 1 compare_constraints_violation ( problem , logg ); For this example the violation of the power flow equations, the bus specifications, and the consensus constraints are shown below per Aladin iteration. Entire code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 clear all ; close all ; clc ; addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); names = generate_name_struct (); %% setup fields_to_merge = { 'bus' , 'gen' , 'branch' }; mpc_master = loadcase ( 'case14' ); mpc_workers = { loadcase ( 'case30' ) loadcase ( 'case9' ) }; connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; conn = build_connection_table ( connection_array , trafo_params ); %% main % case-file-generator mpc_merge = run_case_file_generator ( mpc_master , mpc_workers , conn , fields_to_merge , names ); % case-file-splitter mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); % generate problem formulation for aladin problem = generate_distributed_problem_for_aladin ( mpc_split , names , 'least-squares' ); % add a solver problem . solver = 'fmincon' ; % validate problem formulation [ xval , xval_stacked ] = validate_distributed_problem_formulation ( problem , mpc_split , names ); opts = struct ( 'maxiter' , 50 , 'solveQP' , 'MA57' ); opts . reg = 'false' ; opts . rho0 = 1e2 ; [ xsol_aladin , xsol_stack_aladin , mpc_sol_aladin , logg ] = solve_distributed_problem_with_aladin ( mpc_split , problem , names , opts ); comparison_aladin = compare_results ( xval , xsol_aladin ) compare_constraints_violation ( problem , logg );","title":"Example"},{"location":"example/#example","text":"This is a beginning-to-end-example about how to solve distributed power flow with the Aladin toolbox . Click here to see the plain code.","title":"Example"},{"location":"example/#setup","text":"Starting from the home directory of the package, let\u2019s make a tabula rasa and switch to the use case folder 1 2 clear all ; close all ; clc ; cd ( '00_use-case' ) If not done already, add the source files to the path 1 2 3 addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); We would like the following fields to be merged from the case files 1 fields_to_merge = { 'bus' , 'gen' , 'branch' };","title":"Setup"},{"location":"example/#specify-inputs","text":"We first generate a name struct that acts as a de-facto global variable for naming structs. 1 names = generate_name_struct (); Next, we specify the master and worker systems by loading their case files. 1 2 mpc_master = loadcase ( 'case14' ); mpc_workers = { loadcase ( 'case30' ); loadcase ( 'case9' ) }; Additionally, we need to specify who is connected to whom . These connections are specified in a connection array: 1 2 3 connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; The first row reads: system 2 is connected to system 1, specifically the first bus of system 2 is connected to the second bus of system 1. Likewise, the second row reads: system 2 is connected to system 3, specifically the second bus of system 2 is connected to the third bus of system 3. However, we need not just to specify who is connected to whom , but also how . Hence, we model a connecting transformer. 1 2 3 4 5 trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; Finally, we can call build_connection_table . 1 conn = build_connection_table ( connection_array , trafo_params );","title":"Specify inputs"},{"location":"example/#problem-formulation","text":"Having done the setup, we are now ready to use the three main blocks: the case file generator, the case file splitter, and the case file parser:","title":"Problem formulation"},{"location":"example/#case-file-generator","text":"Calling the case file generator means to specify the master and the workers together with the connection table, and what fields shall be merged. The most convenient way is to call run_case_file_generator 1 mpc_merge = run_case_file_generator ( mpc_master , mpc_workers , conn , fields_to_merge , names ); The output is a case file that has a lot of extra information.","title":"Case file generator"},{"location":"example/#case-file-splitter","text":"The output of the case file generator is the input to the case file splitter, together with connection information. We call run_case_file_splitter 1 mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); The output is, again, a case file that has a lot of extra information.","title":"Case file splitter"},{"location":"example/#case-file-parser","text":"Finally, the case file parser takes the output from the splitter, and generates a problem formulation, using generate_distributed_problem_for_aladin . Note that we can need to specify whether we create a feasibility or a least-squares problem formulation. 1 problem = generate_distributed_problem_for_aladin ( mpc_split , names , 'least-squares' ); The problem formulation is a struct that contains all relevant equations. Finally, we need to add a numerical solver ( fmincon , fminunc , worhp , Casadi+Ipopt ) 1 2 % add a solver problem . solver = 'fmincon' ;","title":"Case file parser"},{"location":"example/#problem-solution","text":"Having created a valid problem formulation, we rely on the Aladin toolbox to solve the problem. Aladin requires a set of parameters (using the default values is also possible, and usually a good idea). We use the function solve_distributed_problem_with_aladin 1 2 3 4 5 opts = struct ( 'maxiter' , 50 , 'solveQP' , 'MA57' ); opts . reg = 'false' ; opts . rho0 = 1e2 ; [ xsol_aladin , xsol_stack_aladin , mpc_sol_aladin , logg ] = solve_distributed_problem_with_aladin ( mpc_split , problem , names , opts ); The function returns four outputs: xsol_aladin and xsol_stack_aladin are both cells with as many entries as there are regions. In each entry, the state of region i i is stored: in xsol_aladin it is a matrix form with as many rows as there are buses in the region, and the four columns being the voltage angle, the voltage magnitude, the net active power, and the net reactive power; in xsol_stack_aladin , each entry is the vertically stacked equivalent of xsol_aladin . The third output, mpc_sol_aladin , is a valid case file that can be used for further inspection. The fourth output contains logging information from the Aladin toolbox.","title":"Problem solution"},{"location":"example/#comparison","text":"How do we know that the solution we computed is actually correct? For that purpose, there is a validation function such as validate_distributed_problem_formulation . Simply put, the function uses matpower to validate that the generated problem formulation stored in problem is correct. 1 [ xval , xval_stacked ] = validate_distributed_problem_formulation ( problem , mpc_split , names ); The outputs have the same format as the first two outputs ( xsol_aladin & xsol_stack_aladin ) from the problem solution . To compare the results we call compare_results , which generates a humand-readable table output. 1 comparison_aladin = compare_results ( xval , xsol_aladin )","title":"Comparison"},{"location":"example/#post-processing","text":"There is a handy function for post-processing, This function provides a graphical impression of the overall constraint violations for both the power flow equations and the consensus violations. 1 compare_constraints_violation ( problem , logg ); For this example the violation of the power flow equations, the bus specifications, and the consensus constraints are shown below per Aladin iteration.","title":"Post-processing"},{"location":"example/#entire-code","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 clear all ; close all ; clc ; addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); names = generate_name_struct (); %% setup fields_to_merge = { 'bus' , 'gen' , 'branch' }; mpc_master = loadcase ( 'case14' ); mpc_workers = { loadcase ( 'case30' ) loadcase ( 'case9' ) }; connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; conn = build_connection_table ( connection_array , trafo_params ); %% main % case-file-generator mpc_merge = run_case_file_generator ( mpc_master , mpc_workers , conn , fields_to_merge , names ); % case-file-splitter mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); % generate problem formulation for aladin problem = generate_distributed_problem_for_aladin ( mpc_split , names , 'least-squares' ); % add a solver problem . solver = 'fmincon' ; % validate problem formulation [ xval , xval_stacked ] = validate_distributed_problem_formulation ( problem , mpc_split , names ); opts = struct ( 'maxiter' , 50 , 'solveQP' , 'MA57' ); opts . reg = 'false' ; opts . rho0 = 1e2 ; [ xsol_aladin , xsol_stack_aladin , mpc_sol_aladin , logg ] = solve_distributed_problem_with_aladin ( mpc_split , problem , names , opts ); comparison_aladin = compare_results ( xval , xsol_aladin ) compare_constraints_violation ( problem , logg );","title":"Entire code"},{"location":"getting-started/","text":"Getting started Once you have setup everything correctly , the easiest way to get started, is to play with some implemented test cases. Simply open and run 00_use-case/getting_started.m . This will open a GUI, from which you can select a case of your choice. In addition, you can select the problem type, and the solver with which to solve the problem. A more detailed example is covered here . External solvers For Casadi and worhp to work you need to make sure they run on your machine.","title":"Getting started"},{"location":"getting-started/#getting-started","text":"Once you have setup everything correctly , the easiest way to get started, is to play with some implemented test cases. Simply open and run 00_use-case/getting_started.m . This will open a GUI, from which you can select a case of your choice. In addition, you can select the problem type, and the solver with which to solve the problem. A more detailed example is covered here . External solvers For Casadi and worhp to work you need to make sure they run on your machine.","title":"Getting started"},{"location":"installation/","text":"Installation Install Matlab . Add Matpower to your Matlab installation Add Aladin to your Matlab installation. Make sure to switch to the abstractify branch if you want to use Aladin without Casadi . Branch abstractify The branch abstractify is actively being developed. Be prepared to see breaking changes and unintended behavior. Use of matpower The code relies heavily on Matpower , especially on the idea of a matpower case file (or mpc ). This bulky name is nothing but a standardized Matlab struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, mpc can be converted within matpower to/from IEEE CDF or PSS/E RAW, see the Matpower docs for details.","title":"Installation"},{"location":"installation/#installation","text":"Install Matlab . Add Matpower to your Matlab installation Add Aladin to your Matlab installation. Make sure to switch to the abstractify branch if you want to use Aladin without Casadi . Branch abstractify The branch abstractify is actively being developed. Be prepared to see breaking changes and unintended behavior. Use of matpower The code relies heavily on Matpower , especially on the idea of a matpower case file (or mpc ). This bulky name is nothing but a standardized Matlab struct, with the advantage that it has become a de facto standard for Matlab-based power systems research. Also, mpc can be converted within matpower to/from IEEE CDF or PSS/E RAW, see the Matpower docs for details.","title":"Installation"},{"location":"overview/","text":"Overview The code consists of three main blocks, listed in the following table. Name Function Case file generator Merge several case files & connection information Case file splitter Adjust case files to account for core and copy nodes Case file parser Generate mathematical problem formulation Their relationship is shown in the following: The interface of the blocks is made up of matpower case files. This allows to leverage all of the built-in functionality that comes with matpower . Visualizing case files There is an exquisite open source tool for visualizing case files: simply drag and drop a valid case file and be merry. Specifically the input to the case file generator consists of several case files and their connection information; the connection information encodes who is connected to whom and by what kind of transformer. The output of the case file generator is, again, a case file, which is then fed to the case file splitter. The splitter adds information to each individual case file about neighboring buses. This is then fed to the caes file parser (in the form of a case file) whose output is a mathematial problem formulation in terms of function handles. The case file parser also generates sensitivities of the power flow problem. Allowed connections Systems can be connected in arbitrary ways at generation buses, for instance: There may be several connections between two systems too. Warning It is currently not supported to connect several lines between the same buses.","title":"Overview"},{"location":"overview/#overview","text":"The code consists of three main blocks, listed in the following table. Name Function Case file generator Merge several case files & connection information Case file splitter Adjust case files to account for core and copy nodes Case file parser Generate mathematical problem formulation Their relationship is shown in the following: The interface of the blocks is made up of matpower case files. This allows to leverage all of the built-in functionality that comes with matpower . Visualizing case files There is an exquisite open source tool for visualizing case files: simply drag and drop a valid case file and be merry. Specifically the input to the case file generator consists of several case files and their connection information; the connection information encodes who is connected to whom and by what kind of transformer. The output of the case file generator is, again, a case file, which is then fed to the case file splitter. The splitter adds information to each individual case file about neighboring buses. This is then fed to the caes file parser (in the form of a case file) whose output is a mathematial problem formulation in terms of function handles. The case file parser also generates sensitivities of the power flow problem.","title":"Overview"},{"location":"overview/#allowed-connections","text":"Systems can be connected in arbitrary ways at generation buses, for instance: There may be several connections between two systems too. Warning It is currently not supported to connect several lines between the same buses.","title":"Allowed connections"},{"location":"problem-formulation/","text":"Problem formulation Here we present the mathematical formulation of the distributed power flow problem, which simply reads \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0. \\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0. \\end{aligned} In plain words, the first set of equations satisfies the power flow equations in each region i i , the second set of equations accounts for the bus specifications, and the third set of equations ensures consensus among the nodes that are shared between regions (will be explained below). Its advantage is that its solution\u2014supposing it exists\u2014is mathematically equivalent to the original power flow problem. Instead of often done splitting of lines we simply copy neighboring buses within regions. With rapidPF, the distributed power flow problem can be solved in two different problem formulations: as a distributed feasibility problem, or as a distributed least-squares problem. What problem formulation to use From our experience, the distributed least-squares formulation works better. Core nodes & copy nodes Suppose we have a grid that looks like as follows There are a total of 12 12 buses in the system. The dashed lines indicate the three different regions: buses \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} belong to what we call the master system, buses \\{4, 5, 6, 7 \\} \\{4, 5, 6, 7 \\} belong to what we call the (first) worker system, and buses \\{ 8, 9, 10, 11, 12 \\} \\{ 8, 9, 10, 11, 12 \\} belong to the (second) worker system. Hence, we distinguish between master and worker systems; these local or regional systems (or just subsystems ) make up the overall power system. For the overall system the power flow problem means to compute the values \\begin{aligned} x_i = \\begin{bmatrix} \\theta_i \\\\ v_i \\\\ p_i \\\\ q_i \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n}\\end{aligned} \\begin{aligned} x_i = \\begin{bmatrix} \\theta_i \\\\ v_i \\\\ p_i \\\\ q_i \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n}\\end{aligned} for all i \\in \\{1, \\dots, 12 \\} i \\in \\{1, \\dots, 12 \\} . A prototypical power flow problem can be formulated mathematically as a system of nonlinear equations of the form \\begin{aligned} g^{\\text{pf}}( x) &= 0, \\\\ g^{\\text{bus}}( x) &= 0, \\end{aligned} \\begin{aligned} g^{\\text{pf}}( x) &= 0, \\\\ g^{\\text{bus}}( x) &= 0, \\end{aligned} where g^{\\text{pf}}( x) = 0 g^{\\text{pf}}( x) = 0 constitutes the 2 \\times 12 2 \\times 12 power flow equations, and g^{\\text{bus}}( x) = 0 g^{\\text{bus}}( x) = 0 stands for the remaining 2 \\times 12 2 \\times 12 bus specifications. This yields a total of 4 \\times 12 4 \\times 12 equations for 4 \\times 12 4 \\times 12 unknowns. Arguably, this leads to large systems of nonlinear equations as soon as the number of buses in the power system increases. From here on we call this prototypical power flow problem we just described the centralized power flow problem. The idea of distributed power flow is to solve local power flow problems within each system (= the master system, and all of the worker systems), independent of each other, and iterate for as long as necessary until the solution of the centralized problem is obtained. Iteration here means to find consensus on the physical values of the exchanged power between the subsystems. Before making this idea mathematically precise we introduce some more Nomenclature. Suppose we are seated in the master system, the one composed of buses \\{1, 2, 3 \\} \\{1, 2, 3 \\} . From our perspective both worker systems are our neighbors . More precisely, we know only that bus 4 4 (located in the first worker system) is our connection to the first worker system. Likewise, bus 8 8 (located in the second worker system) is our connection to the second worker system. To distinguish between these different kinds of buses we call the buses \\{1, 2, 3 \\} \\{1, 2, 3 \\} the core nodes of the master system, and buses \\{ 4, 8\\} \\{ 4, 8\\} the copy nodes. Importantly, all other nodes do not exist for us; they are ignored. Graphically, our world looks as follows. Why the term copy ? Because when formulating the power flow equations for the master system we need to know the voltages at the copy nodes. And in case we don\u2019t know the values (which we really don\u2019t because the copy nodes do not belong to our jurisdiction), then we have to assume values for them. This can be thought of as copying the buses into the shaded are denoted as \u201c \\text{copy + core nodes} \\text{copy + core nodes} ,\u201d hence the name. Taking on the perspective of the first worker system we see: our core nodes are \\{ 4, 5, 6, 7 \\} \\{ 4, 5, 6, 7 \\} , and there is just one copy bus 1 1 , the first bus in the master system. Our world looks as follows. Being able to distinguish between core nodes and copy nodes allows to formulate the distributed power flow clearer: solve the power flow problem in each subsystem and attain consensus between the copy nodes and their core node equivalents. By core node equivalent we mean the following: the first copy bus of the master system has bus 4 4 as its core node equivalent. It is clear from intuition that if the voltage at the copy node in each subsystem corresponds to the value of its core node equivalent, then the solution of the distributed power flow problem is the same as the solution from the centralized power flow problem. Let us make these ideas mathematically more precise. Local power flow problem The following table collects symbols and their meanings as they are used throughout. Symbol Meaning n^{\\text{reg}} n^{\\text{reg}} Number of regions n^{\\text{conn}} n^{\\text{conn}} Number of connecting lines between regions n^\\text{core}_{i} n^\\text{core}_{i} Number of core nodes in region i i n^\\text{copy}_{i} n^\\text{copy}_{i} Number of copy nodes in region i i x_{i} x_{i} State of core nodes in region i i z_{i} z_{i} State of copy nodes in region i i We compose the set of buses of each region i i into a set of core nodes , and a set of copy nodes . The core nodes are the original nodes that make up the power system. The copy nodes are the nodes that connect the power system to the neighboring power systems. Hence, the copy nodes do not belong to the power system but to its neighbors. The sole purpose of the copy nodes is to store the complex voltage information at the neighboring buses such that power flow equations can be constructed. The state of the core nodes contains the voltage angles, the voltage magnitudes, the net active power, and the net reactive power of all core nodes \\begin{aligned} \\label{eq:state-core} x_i = \\begin{bmatrix} \\theta_i^\\text{core} \\\\ v_i^\\text{core} \\\\ p_i^\\text{core} \\\\ q_i^\\text{core} \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n^\\text{core}_i}.\\end{aligned} \\begin{aligned} \\label{eq:state-core} x_i = \\begin{bmatrix} \\theta_i^\\text{core} \\\\ v_i^\\text{core} \\\\ p_i^\\text{core} \\\\ q_i^\\text{core} \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n^\\text{core}_i}.\\end{aligned} The state of the copy nodes contains the voltage angles and the voltage magnitudes of all copy nodes \\begin{aligned} \\label{eq:state-copy} z_i = \\begin{bmatrix} \\theta_i^\\text{copy} \\\\ v_i^\\text{copy} \\end{bmatrix} \\in \\mathbb{R}^{2 n^\\text{copy}_i}.\\end{aligned} \\begin{aligned} \\label{eq:state-copy} z_i = \\begin{bmatrix} \\theta_i^\\text{copy} \\\\ v_i^\\text{copy} \\end{bmatrix} \\in \\mathbb{R}^{2 n^\\text{copy}_i}.\\end{aligned} We see: each region i i is described by a total of 4 n^\\text{core}_i + 2 n^\\text{copy}_i 4 n^\\text{core}_i + 2 n^\\text{copy}_i real numbers. Power flow equations In region i i we formulate a total of 2 n^\\text{core}_i 2 n^\\text{core}_i power flow equations g^{\\text{pf}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\times \\mathbb{R}^{2 n^\\text{copy}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} g^{\\text{pf}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\times \\mathbb{R}^{2 n^\\text{copy}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i) = 0.\\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i) = 0.\\end{aligned} Bus specifications In region i i we formulate a total of 2 n^\\text{core}_i 2 n^\\text{core}_i bus specifications g^{\\text{bus}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} g^{\\text{bus}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes \\begin{aligned} g^{\\text{bus}}_i( x_i) = 0.\\end{aligned} \\begin{aligned} g^{\\text{bus}}_i( x_i) = 0.\\end{aligned} Degrees of freedom Subtracting the number of equations from the number of decision variables gives us a total of \\begin{aligned} \\underbrace{4 n^\\text{core}_i + 2 n^\\text{copy}_i}_{\\text{Decision variables}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Power flow equations}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Bus specifications}} = \\underbrace{2 n^\\text{copy}_i}_{\\text{Degrees of freedom}}\\end{aligned} \\begin{aligned} \\underbrace{4 n^\\text{core}_i + 2 n^\\text{copy}_i}_{\\text{Decision variables}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Power flow equations}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Bus specifications}} = \\underbrace{2 n^\\text{copy}_i}_{\\text{Degrees of freedom}}\\end{aligned} degrees of freedom for each region i i . These degrees of freedom must be fixed globally by the consensus constraints. Decentralized power flow problem \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0, \\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0, \\end{aligned} where the consensus matrices A_i \\in \\mathbb{R}^{4 n^{\\text{conn}}\\times (4 n^\\text{core}_i + 2 n^\\text{copy}_i)} A_i \\in \\mathbb{R}^{4 n^{\\text{conn}}\\times (4 n^\\text{core}_i + 2 n^\\text{copy}_i)} enforce equality of the voltage angle and the voltage magnitude at the copy buses and their respective original buses.","title":"Problem formulation"},{"location":"problem-formulation/#problem-formulation","text":"Here we present the mathematical formulation of the distributed power flow problem, which simply reads \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0. \\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0. \\end{aligned} In plain words, the first set of equations satisfies the power flow equations in each region i i , the second set of equations accounts for the bus specifications, and the third set of equations ensures consensus among the nodes that are shared between regions (will be explained below). Its advantage is that its solution\u2014supposing it exists\u2014is mathematically equivalent to the original power flow problem. Instead of often done splitting of lines we simply copy neighboring buses within regions. With rapidPF, the distributed power flow problem can be solved in two different problem formulations: as a distributed feasibility problem, or as a distributed least-squares problem. What problem formulation to use From our experience, the distributed least-squares formulation works better.","title":"Problem formulation"},{"location":"problem-formulation/#core-nodes-copy-nodes","text":"Suppose we have a grid that looks like as follows There are a total of 12 12 buses in the system. The dashed lines indicate the three different regions: buses \\{ 1, 2, 3 \\} \\{ 1, 2, 3 \\} belong to what we call the master system, buses \\{4, 5, 6, 7 \\} \\{4, 5, 6, 7 \\} belong to what we call the (first) worker system, and buses \\{ 8, 9, 10, 11, 12 \\} \\{ 8, 9, 10, 11, 12 \\} belong to the (second) worker system. Hence, we distinguish between master and worker systems; these local or regional systems (or just subsystems ) make up the overall power system. For the overall system the power flow problem means to compute the values \\begin{aligned} x_i = \\begin{bmatrix} \\theta_i \\\\ v_i \\\\ p_i \\\\ q_i \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n}\\end{aligned} \\begin{aligned} x_i = \\begin{bmatrix} \\theta_i \\\\ v_i \\\\ p_i \\\\ q_i \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n}\\end{aligned} for all i \\in \\{1, \\dots, 12 \\} i \\in \\{1, \\dots, 12 \\} . A prototypical power flow problem can be formulated mathematically as a system of nonlinear equations of the form \\begin{aligned} g^{\\text{pf}}( x) &= 0, \\\\ g^{\\text{bus}}( x) &= 0, \\end{aligned} \\begin{aligned} g^{\\text{pf}}( x) &= 0, \\\\ g^{\\text{bus}}( x) &= 0, \\end{aligned} where g^{\\text{pf}}( x) = 0 g^{\\text{pf}}( x) = 0 constitutes the 2 \\times 12 2 \\times 12 power flow equations, and g^{\\text{bus}}( x) = 0 g^{\\text{bus}}( x) = 0 stands for the remaining 2 \\times 12 2 \\times 12 bus specifications. This yields a total of 4 \\times 12 4 \\times 12 equations for 4 \\times 12 4 \\times 12 unknowns. Arguably, this leads to large systems of nonlinear equations as soon as the number of buses in the power system increases. From here on we call this prototypical power flow problem we just described the centralized power flow problem. The idea of distributed power flow is to solve local power flow problems within each system (= the master system, and all of the worker systems), independent of each other, and iterate for as long as necessary until the solution of the centralized problem is obtained. Iteration here means to find consensus on the physical values of the exchanged power between the subsystems. Before making this idea mathematically precise we introduce some more Nomenclature. Suppose we are seated in the master system, the one composed of buses \\{1, 2, 3 \\} \\{1, 2, 3 \\} . From our perspective both worker systems are our neighbors . More precisely, we know only that bus 4 4 (located in the first worker system) is our connection to the first worker system. Likewise, bus 8 8 (located in the second worker system) is our connection to the second worker system. To distinguish between these different kinds of buses we call the buses \\{1, 2, 3 \\} \\{1, 2, 3 \\} the core nodes of the master system, and buses \\{ 4, 8\\} \\{ 4, 8\\} the copy nodes. Importantly, all other nodes do not exist for us; they are ignored. Graphically, our world looks as follows. Why the term copy ? Because when formulating the power flow equations for the master system we need to know the voltages at the copy nodes. And in case we don\u2019t know the values (which we really don\u2019t because the copy nodes do not belong to our jurisdiction), then we have to assume values for them. This can be thought of as copying the buses into the shaded are denoted as \u201c \\text{copy + core nodes} \\text{copy + core nodes} ,\u201d hence the name. Taking on the perspective of the first worker system we see: our core nodes are \\{ 4, 5, 6, 7 \\} \\{ 4, 5, 6, 7 \\} , and there is just one copy bus 1 1 , the first bus in the master system. Our world looks as follows. Being able to distinguish between core nodes and copy nodes allows to formulate the distributed power flow clearer: solve the power flow problem in each subsystem and attain consensus between the copy nodes and their core node equivalents. By core node equivalent we mean the following: the first copy bus of the master system has bus 4 4 as its core node equivalent. It is clear from intuition that if the voltage at the copy node in each subsystem corresponds to the value of its core node equivalent, then the solution of the distributed power flow problem is the same as the solution from the centralized power flow problem. Let us make these ideas mathematically more precise.","title":"Core nodes &amp; copy nodes"},{"location":"problem-formulation/#local-power-flow-problem","text":"The following table collects symbols and their meanings as they are used throughout. Symbol Meaning n^{\\text{reg}} n^{\\text{reg}} Number of regions n^{\\text{conn}} n^{\\text{conn}} Number of connecting lines between regions n^\\text{core}_{i} n^\\text{core}_{i} Number of core nodes in region i i n^\\text{copy}_{i} n^\\text{copy}_{i} Number of copy nodes in region i i x_{i} x_{i} State of core nodes in region i i z_{i} z_{i} State of copy nodes in region i i We compose the set of buses of each region i i into a set of core nodes , and a set of copy nodes . The core nodes are the original nodes that make up the power system. The copy nodes are the nodes that connect the power system to the neighboring power systems. Hence, the copy nodes do not belong to the power system but to its neighbors. The sole purpose of the copy nodes is to store the complex voltage information at the neighboring buses such that power flow equations can be constructed. The state of the core nodes contains the voltage angles, the voltage magnitudes, the net active power, and the net reactive power of all core nodes \\begin{aligned} \\label{eq:state-core} x_i = \\begin{bmatrix} \\theta_i^\\text{core} \\\\ v_i^\\text{core} \\\\ p_i^\\text{core} \\\\ q_i^\\text{core} \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n^\\text{core}_i}.\\end{aligned} \\begin{aligned} \\label{eq:state-core} x_i = \\begin{bmatrix} \\theta_i^\\text{core} \\\\ v_i^\\text{core} \\\\ p_i^\\text{core} \\\\ q_i^\\text{core} \\\\ \\end{bmatrix} \\in \\mathbb{R}^{4 n^\\text{core}_i}.\\end{aligned} The state of the copy nodes contains the voltage angles and the voltage magnitudes of all copy nodes \\begin{aligned} \\label{eq:state-copy} z_i = \\begin{bmatrix} \\theta_i^\\text{copy} \\\\ v_i^\\text{copy} \\end{bmatrix} \\in \\mathbb{R}^{2 n^\\text{copy}_i}.\\end{aligned} \\begin{aligned} \\label{eq:state-copy} z_i = \\begin{bmatrix} \\theta_i^\\text{copy} \\\\ v_i^\\text{copy} \\end{bmatrix} \\in \\mathbb{R}^{2 n^\\text{copy}_i}.\\end{aligned} We see: each region i i is described by a total of 4 n^\\text{core}_i + 2 n^\\text{copy}_i 4 n^\\text{core}_i + 2 n^\\text{copy}_i real numbers.","title":"Local power flow problem"},{"location":"problem-formulation/#power-flow-equations","text":"In region i i we formulate a total of 2 n^\\text{core}_i 2 n^\\text{core}_i power flow equations g^{\\text{pf}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\times \\mathbb{R}^{2 n^\\text{copy}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} g^{\\text{pf}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\times \\mathbb{R}^{2 n^\\text{copy}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i) = 0.\\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i) = 0.\\end{aligned}","title":"Power flow equations"},{"location":"problem-formulation/#bus-specifications","text":"In region i i we formulate a total of 2 n^\\text{core}_i 2 n^\\text{core}_i bus specifications g^{\\text{bus}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} g^{\\text{bus}}_i \\colon \\mathbb{R}^{4 n^\\text{core}_i} \\rightarrow \\mathbb{R}^{2 n^\\text{core}_i} for all core nodes \\begin{aligned} g^{\\text{bus}}_i( x_i) = 0.\\end{aligned} \\begin{aligned} g^{\\text{bus}}_i( x_i) = 0.\\end{aligned}","title":"Bus specifications"},{"location":"problem-formulation/#degrees-of-freedom","text":"Subtracting the number of equations from the number of decision variables gives us a total of \\begin{aligned} \\underbrace{4 n^\\text{core}_i + 2 n^\\text{copy}_i}_{\\text{Decision variables}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Power flow equations}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Bus specifications}} = \\underbrace{2 n^\\text{copy}_i}_{\\text{Degrees of freedom}}\\end{aligned} \\begin{aligned} \\underbrace{4 n^\\text{core}_i + 2 n^\\text{copy}_i}_{\\text{Decision variables}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Power flow equations}} - \\underbrace{2 n^\\text{core}_i}_{\\text{Bus specifications}} = \\underbrace{2 n^\\text{copy}_i}_{\\text{Degrees of freedom}}\\end{aligned} degrees of freedom for each region i i . These degrees of freedom must be fixed globally by the consensus constraints.","title":"Degrees of freedom"},{"location":"problem-formulation/#decentralized-power-flow-problem","text":"\\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0, \\end{aligned} \\begin{aligned} g^{\\text{pf}}_i( x_i, z_i ) &= 0 \\\\ g^{\\text{bus}}_i ( x_i ) &= 0 \\\\ \\sum_{i = 1}^{n^{\\text{reg}}} A_i \\begin{bmatrix} x_i \\\\ z_i \\end{bmatrix} &= 0, \\end{aligned} where the consensus matrices A_i \\in \\mathbb{R}^{4 n^{\\text{conn}}\\times (4 n^\\text{core}_i + 2 n^\\text{copy}_i)} A_i \\in \\mathbb{R}^{4 n^{\\text{conn}}\\times (4 n^\\text{core}_i + 2 n^\\text{copy}_i)} enforce equality of the voltage angle and the voltage magnitude at the copy buses and their respective original buses.","title":"Decentralized power flow problem"},{"location":"sensitivities/","text":"Sensitivities This section shows how the power flow sensitivities can be used. All gradient-based optimization methods require sensitivities. By sensitivities we mean one (or all) of the following: gradients, Jacobians, and/or Hessians. Broadly speaking, there are three ways to obtain sensitivities: symbolically, numerically, by automatic differentiation, with each method having its own pros and cons. The case file parser does not just provide the mathematical problem formulation in terms of function handles, but also sensitivities. Computation Naming for sensitivities The naming of the sensitivities is inspired by the naming conventions from Aladin . Letting problem be the output of the case file parser, you find it has an entry sens 1 2 3 4 5 6 7 8 9 >> problem . sens ans = struct with fields: gg : { 3 \u00d7 1 cell } JJac : { 3 \u00d7 1 cell } HH : { 3 \u00d7 1 cell } which has again three entries. The following table gives some background information. Entry Meaning Definition Exact gg Gradient of each local cost function ( see Algorithm 1 here ) \\nabla f_i(x_i) \\nabla f_i(x_i) (zero for power flow problems) Yes JJac Jacobian of each local power flow problem J_{g_i}(x_i, z_i) J_{g_i}(x_i, z_i) where g_i(x_i, z_i) = \\begin{bmatrix} g^{\\text{pf}}_i( x_i, z_i ) \\\\ g^{\\text{bus}}_i ( x_i )) \\end{bmatrix} g_i(x_i, z_i) = \\begin{bmatrix} g^{\\text{pf}}_i( x_i, z_i ) \\\\ g^{\\text{bus}}_i ( x_i )) \\end{bmatrix} Yes HH Hessian of each local problem for Aladin problem formulation ( see Algorithm 1 here ) \\nabla^2 B_i \\nabla^2 B_i with B_i = f_i(x_i) + \\kappa_i^\\top g_i(x_i, z_i) B_i = f_i(x_i) + \\kappa_i^\\top g_i(x_i, z_i) , where \\kappa_i \\kappa_i are the Lagrange multipliers w.r.t. the equality constraints g_i g_i No The Hessian is computed numerically using central differences per default for the feasibility formulation, and by the Gauss-Newton method for the least-squares formulation. These sensitivities should be supplied to numerical solvers to increase both accuracy and speed. Where sensitivities are computed The sensitivities are computed in the file generate_local_power_flow_problem.m . Example Suppose we are interested in power flow for a single-region problem, i.e. a traditional non-distributed setup. Then, we know that we can just apply Newton\u2019s method, for which we need both the equality constraints that specify the power flow problem, and its Jacobian. So, purely for cross validation, let\u2019s solve a power flow problem using the information the case file splitter provides. 1 2 3 4 mpc = ext2int ( loadcase ( 'case30' )); mpc .( names . regions . global ) = 1 : 30 ; mpc .( names . copy_buses . local ) = []; [ cost , ineq , eq , x0 , pf , bus_specifications , Jac ] = generate_local_power_flow_problem ( mpc , names , 'not_required' , 'feasibility' ); Lines 2 and 3 are needed purely for code convention routines: they introduce a sense of global numbering, and specify no neighors. The last line calls the case file parser which returns the Jacobian. Running a prototypical Newton scheme is then straightforward 1 2 3 4 5 6 7 8 9 x = x0 ; tol = 1e-10 ; i = 0 ; while norm(eq(x)) > tol && i < 10 x = x - Jac ( x ) \\ eq ( x ); norm ( eq ( x )) i = i + 1 ; end Putting this together for our example system we have 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 clear all ; close all ; clc ; addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); names = generate_name_struct (); %% setup fields_to_merge = { 'bus' , 'gen' , 'branch' }; mpc_master = loadcase ( 'case14' ); mpc_slaves = { loadcase ( 'case30' ) loadcase ( 'case9' ) }; connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; conn = build_connection_table ( connection_array , trafo_params ); %% main % case-file-generator mpc_merge = run_case_file_generator ( mpc_master , mpc_slaves , conn , fields_to_merge , names ); % case-file-splitter mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); mpc = ext2int ( loadcase ( 'case30' )); mpc .( names . regions . global ) = 1 : 30 ; mpc .( names . copy_buses . local ) = []; [ cost , ineq , eq , x0 , pf , bus_specifications , Jac ] = generate_local_power_flow_problem ( mpc , names , 'my_postfix' , 'feasibility' ); x = x0 ; tol = 1e-10 ; i = 0 ; while norm(eq(x)) > tol && i < 10 x = x - Jac ( x ) \\ eq ( x ); norm ( eq ( x )) i = i + 1 ; end","title":"Sensitivities"},{"location":"sensitivities/#sensitivities","text":"This section shows how the power flow sensitivities can be used. All gradient-based optimization methods require sensitivities. By sensitivities we mean one (or all) of the following: gradients, Jacobians, and/or Hessians. Broadly speaking, there are three ways to obtain sensitivities: symbolically, numerically, by automatic differentiation, with each method having its own pros and cons. The case file parser does not just provide the mathematical problem formulation in terms of function handles, but also sensitivities.","title":"Sensitivities"},{"location":"sensitivities/#computation","text":"Naming for sensitivities The naming of the sensitivities is inspired by the naming conventions from Aladin . Letting problem be the output of the case file parser, you find it has an entry sens 1 2 3 4 5 6 7 8 9 >> problem . sens ans = struct with fields: gg : { 3 \u00d7 1 cell } JJac : { 3 \u00d7 1 cell } HH : { 3 \u00d7 1 cell } which has again three entries. The following table gives some background information. Entry Meaning Definition Exact gg Gradient of each local cost function ( see Algorithm 1 here ) \\nabla f_i(x_i) \\nabla f_i(x_i) (zero for power flow problems) Yes JJac Jacobian of each local power flow problem J_{g_i}(x_i, z_i) J_{g_i}(x_i, z_i) where g_i(x_i, z_i) = \\begin{bmatrix} g^{\\text{pf}}_i( x_i, z_i ) \\\\ g^{\\text{bus}}_i ( x_i )) \\end{bmatrix} g_i(x_i, z_i) = \\begin{bmatrix} g^{\\text{pf}}_i( x_i, z_i ) \\\\ g^{\\text{bus}}_i ( x_i )) \\end{bmatrix} Yes HH Hessian of each local problem for Aladin problem formulation ( see Algorithm 1 here ) \\nabla^2 B_i \\nabla^2 B_i with B_i = f_i(x_i) + \\kappa_i^\\top g_i(x_i, z_i) B_i = f_i(x_i) + \\kappa_i^\\top g_i(x_i, z_i) , where \\kappa_i \\kappa_i are the Lagrange multipliers w.r.t. the equality constraints g_i g_i No The Hessian is computed numerically using central differences per default for the feasibility formulation, and by the Gauss-Newton method for the least-squares formulation. These sensitivities should be supplied to numerical solvers to increase both accuracy and speed. Where sensitivities are computed The sensitivities are computed in the file generate_local_power_flow_problem.m .","title":"Computation"},{"location":"sensitivities/#example","text":"Suppose we are interested in power flow for a single-region problem, i.e. a traditional non-distributed setup. Then, we know that we can just apply Newton\u2019s method, for which we need both the equality constraints that specify the power flow problem, and its Jacobian. So, purely for cross validation, let\u2019s solve a power flow problem using the information the case file splitter provides. 1 2 3 4 mpc = ext2int ( loadcase ( 'case30' )); mpc .( names . regions . global ) = 1 : 30 ; mpc .( names . copy_buses . local ) = []; [ cost , ineq , eq , x0 , pf , bus_specifications , Jac ] = generate_local_power_flow_problem ( mpc , names , 'not_required' , 'feasibility' ); Lines 2 and 3 are needed purely for code convention routines: they introduce a sense of global numbering, and specify no neighors. The last line calls the case file parser which returns the Jacobian. Running a prototypical Newton scheme is then straightforward 1 2 3 4 5 6 7 8 9 x = x0 ; tol = 1e-10 ; i = 0 ; while norm(eq(x)) > tol && i < 10 x = x - Jac ( x ) \\ eq ( x ); norm ( eq ( x )) i = i + 1 ; end Putting this together for our example system we have 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 clear all ; close all ; clc ; addpath ( genpath ( '../01_generator/' )); addpath ( genpath ( '../02_splitter/' )); addpath ( genpath ( '../03_parser/' )); names = generate_name_struct (); %% setup fields_to_merge = { 'bus' , 'gen' , 'branch' }; mpc_master = loadcase ( 'case14' ); mpc_slaves = { loadcase ( 'case30' ) loadcase ( 'case9' ) }; connection_array = [ 2 1 1 2 ; 2 3 2 3 ; 2 3 13 1 ; ]; trafo_params . r = 0 ; trafo_params . x = 0.00623 ; trafo_params . b = 0 ; trafo_params . ratio = 0.985 ; trafo_params . angle = 0 ; conn = build_connection_table ( connection_array , trafo_params ); %% main % case-file-generator mpc_merge = run_case_file_generator ( mpc_master , mpc_slaves , conn , fields_to_merge , names ); % case-file-splitter mpc_split = run_case_file_splitter ( mpc_merge , conn , names ); mpc = ext2int ( loadcase ( 'case30' )); mpc .( names . regions . global ) = 1 : 30 ; mpc .( names . copy_buses . local ) = []; [ cost , ineq , eq , x0 , pf , bus_specifications , Jac ] = generate_local_power_flow_problem ( mpc , names , 'my_postfix' , 'feasibility' ); x = x0 ; tol = 1e-10 ; i = 0 ; while norm(eq(x)) > tol && i < 10 x = x - Jac ( x ) \\ eq ( x ); norm ( eq ( x )) i = i + 1 ; end","title":"Example"},{"location":"mfiles/01_generator/create_skeleton_mpc/","text":"create_skeleton_mpc mpc = create_skeleton_mpc(data, field_names, names) Create a skeleton case file from data and the specified field_names","title":"create_skeleton_mpc"},{"location":"mfiles/01_generator/create_skeleton_mpc/#create_skeleton_mpc","text":"mpc = create_skeleton_mpc(data, field_names, names) Create a skeleton case file from data and the specified field_names","title":"create_skeleton_mpc"},{"location":"mfiles/01_generator/merge_systems/","text":"merge_systems mpc = merge_systems(mpc_master, mpc_slave, pars, names) Merge the master system and the slave system to another case file mpc The physical information about the connecting transformer is stored in pars .","title":"merge_systems"},{"location":"mfiles/01_generator/merge_systems/#merge_systems","text":"mpc = merge_systems(mpc_master, mpc_slave, pars, names) Merge the master system and the slave system to another case file mpc The physical information about the connecting transformer is stored in pars .","title":"merge_systems"},{"location":"mfiles/01_generator/run_case_file_generator/","text":"run_case_file_generator mpc = run_case_file_generator(mpc_master, mpc_slaves, connection_table, fields_to_merge, names) Generate a merged case file mpc from mpc_master and mpc_slaves according to the connection_table The auxiliary inputs fields_to_merge and names are basic requirements with obvious meanings.","title":"run_case_file_generator"},{"location":"mfiles/01_generator/run_case_file_generator/#run_case_file_generator","text":"mpc = run_case_file_generator(mpc_master, mpc_slaves, connection_table, fields_to_merge, names) Generate a merged case file mpc from mpc_master and mpc_slaves according to the connection_table The auxiliary inputs fields_to_merge and names are basic requirements with obvious meanings.","title":"run_case_file_generator"},{"location":"mfiles/02_splitter/add_consensus_information/","text":"add_consensus_information copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"add_consensus_information"},{"location":"mfiles/02_splitter/add_consensus_information/#add_consensus_information","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"add_consensus_information"},{"location":"mfiles/02_splitter/add_consensus_information/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/02_splitter/run_case_file_splitter/","text":"run_case_file_splitter copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"run_case_file_splitter"},{"location":"mfiles/02_splitter/run_case_file_splitter/#run_case_file_splitter","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"run_case_file_splitter"},{"location":"mfiles/02_splitter/run_case_file_splitter/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/02_splitter/split_case_file/","text":"split_case_file copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"split_case_file"},{"location":"mfiles/02_splitter/split_case_file/#split_case_file","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"split_case_file"},{"location":"mfiles/02_splitter/split_case_file/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/03_parser/build_consensus_constraints/","text":"build_consensus_constraints copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"build_consensus_constraints"},{"location":"mfiles/03_parser/build_consensus_constraints/#build_consensus_constraints","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"build_consensus_constraints"},{"location":"mfiles/03_parser/build_consensus_constraints/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/03_parser/create_bus_specifications/","text":"create_bus_specifications copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"create_bus_specifications"},{"location":"mfiles/03_parser/create_bus_specifications/#create_bus_specifications","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"create_bus_specifications"},{"location":"mfiles/03_parser/create_bus_specifications/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/03_parser/run_ADMM_cplex/","text":"","title":"run ADMM cplex"},{"location":"mfiles/03_parser/solve_distributed_problem_with_admm_cplex/","text":"solve_distributed_problem_with_aladin copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter 1 2 3 params.max_iter = params.max_iter; params.tol = 1e-6; params.rou = params.rho;","title":"solve_distributed_problem_with_aladin"},{"location":"mfiles/03_parser/solve_distributed_problem_with_admm_cplex/#solve_distributed_problem_with_aladin","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"solve_distributed_problem_with_aladin"},{"location":"mfiles/03_parser/solve_distributed_problem_with_admm_cplex/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter 1 2 3 params.max_iter = params.max_iter; params.tol = 1e-6; params.rou = params.rho;","title":"Markdown formatting is supported"},{"location":"mfiles/03_parser/solve_distributed_problem_with_aladin/","text":"solve_distributed_problem_with_aladin copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"solve_distributed_problem_with_aladin"},{"location":"mfiles/03_parser/solve_distributed_problem_with_aladin/#solve_distributed_problem_with_aladin","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"solve_distributed_problem_with_aladin"},{"location":"mfiles/03_parser/solve_distributed_problem_with_aladin/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"},{"location":"mfiles/03_parser/validate_distributed_problem_formulation/","text":"validate_distributed_problem_formulation copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line Markdown formatting is supported Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"validate_distributed_problem_formulation"},{"location":"mfiles/03_parser/validate_distributed_problem_formulation/#validate_distributed_problem_formulation","text":"copy the declaration of the function in here (leave the ticks unchanged) describe what the function does in the following line","title":"validate_distributed_problem_formulation"},{"location":"mfiles/03_parser/validate_distributed_problem_formulation/#markdown-formatting-is-supported","text":"Equations are possible to, e.g a^2 + b^2 = c^2 a^2 + b^2 = c^2 . So are lists: item 1 item 2 1 2 3 4 function y = square ( x ) x ^ 2 end See also: run_case_file_splitter","title":"Markdown formatting is supported"}]}